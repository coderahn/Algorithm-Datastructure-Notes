'''[1.수자료형]'''

'''1)정수형'''

'''2)실수형'''
#소수부 또는 정수부가 0인 소수는 생략 가능
a = 5.
print(a) #5.0
b = -.7
print(b) #-0.7

#e,E를 사용하여 지수 표현 방식 사용 가능

#10억의 지수 표현 방식
c = 1e9 #10^9와 같음
print(c) #1000000000.0

#실수를 정확히 표현 못하므로 round()함수 사용 필요
d = 0.3 + 0.6 
print(d) #0.9가 아니라 0.8999..로 나옴

print(round(d,4)) #소수 5째 자리에서 반올림하여 0.9000(0.9)

'''3)수자료형 연산'''

#//는 소수점 버린 몫만 얻기
e = 7
f = 3

print(e//f) #2

'''[2.리스트 자료형]'''

'''1)리스트 만들기'''
 #초기화방법 두가지
list1 = []
list2 = list() 

#모든값이 0인 n크기 리스트 초기화
n=10
list3 = [0]*n
print(list3) #[0,0,0,0,0,0,0,0,0,0]

'''2)리스트의 인덱싱과 슬라이싱'''

list4 = [1,2,3,4,5,6,7,8,9]
#뒤에서 첫번째 원소 출력
print(list4[-1]) #9

#슬라이싱(list[index1:index2] 방식으로 범위 가져오기)

#[2,3,4] 가져오기
print(list4[1:4]) #[2,3,4]

'''3)리스트 컴프리헨션'''

#0~19까지 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i%2==1]
print(array) #[1,3,5...19]

#1~9까지 수 제곱 리스트
array2 = [i*i for i in range(1,10)]
print(array2) #[1,4,9..81]

#2차원 리스트 초기화시 유용한 리스트 컴프리헨션 - N*M크기 2차원 리스트 0으로 초기화
n=3
m=4
array3 = [[0]*m for _ in range(n)]
print(array3) #[[0,0,0,0],[0,0,0,0],[0,0,0,0]]

#[[0]*m]*n으로 초기화 하면 의도하지 않은 결과 나올 수 있으므로 주의(특정 크기 2차원 리스트 초기화시 리스트 컴프리헨션 필수)
n=3
m=4
array4 = [[0] * m] * n
array4[1][1] = 5
print(array4) #[[0,5,0,0],[0,5,0,0],[0,5,0,0]]으로 나옴 -> 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 떄문

'''4)리스트 관련 기타 메서드'''

#append(), insert(삽입위치 인덱스, 삽입값)
#reverse(): 리스트 원소 뒤집기
#count(특정값) 특정값 데이터개수 세기
#a.remove(특정값) 삭제
 
#insert, remove는 시간복잡도 O(N) -> 리스트 중간에 원소 추가 및 삭제 뒤에 원소 위치를 조정해줘야 하기 때문

#특정 값 원소 제거를 위한 유용한 방법

a = [1,2,3,4,5,5,5]
remove_set = {3,5} #{}는 집합자료형

#remove_set에 포함되지 않은 값만 저장

result = [i for i in a if i not in remove_set]
print(result) #[1,2,4]

'''[3.문자열 자료형]'''

'''1)문자열 초기화'''

'''2)문자열 연산'''

#문자열에 양의 정수 곱하면 그 값만큼 반복 더하기 됨
a = "String"
print(a*3) #StringStringString

#파이썬 문자열은 리스트와 같이 처리됨. 인덱스 슬라이싱 사용 가능
b = "ABCDEF"
print(b[0]) #A

'''[4.튜플 자료형]'''

#튜플은 변경 불가, 소괄호() 사용

a = (1,2,3,4)
#a[0]=5 #TypeError: 'tuple' object does not support item assignment

'''[5.사전 자료형]'''

'''1)사전 자료형 소개'''

#키값쌍 / dict()로 선언 / 내부적으로 해시테이블 -> O(1) 시간복잡도로 이용 가능
#리스트보다 빠르다

data = dict()
data['사과'] = 'apple'
data['바나나'] = 'banana'
data['키위'] = 'kiwi'

print(data) #{'사과': 'apple', '바나나': 'banana', '키위': 'kiwi'}

#in문법으로 특정 자료 찾기 가능(리스트, 튜플도 가능)
if '사과' in data:
  print('사과가 있다')

'''2)사전 자료형 관련 함수'''

#keys(): 키만 뽑기
print(data.keys()) #dict_keys(['사과', '바나나', '키위'])
print(data.values()) #dict_values(['apple', 'banana', 'kiwi'])

'''[6.집합 자료형]'''

'''1)집합자료형 소개'''
#일반적인 set과 같은 특징(중복허용X, 순서없음)
#사전자료형, 집합자료형은 순서가 없기 때문에 인덱스와 슬라이싱 사용 불가
#시간복잡도 O(1)

#집합자료형 초기화 2가지 방법
data = set([1,2,3,4,4,5]) 
print(data) #{1,2,3,4,5}
data2 = {1,2,3,4,4,5}
print(data) #{1,2,3,4,5}

'''2)집합자료형의 연산'''
set1 = set([1,2,3,4,5])
set2 = set([3,4,5,6,7])

print(set1|set2) #합집합: {1,2,3,4,5,6,7}
print(set1&set2) #교집합: {3,4,5}
print(set1-set2) #차집합: {1,2}

'''3)집합자료형 관련 함수'''

set3 = set([1,2,3])

#원소추가
set3.add(4)
print(set3) #{1,2,3,4}

#원소들추가
set3.update([8,9])
print(set3) #{1,2,3,4,8,9}