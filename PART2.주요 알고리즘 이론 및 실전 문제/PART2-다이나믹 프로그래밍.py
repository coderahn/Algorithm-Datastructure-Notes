###다이나믹 프로그래밍(DP)###

'''
-DP를 이용하여 피보나치 수열을 해결할 수 있음
-피보나치 수열은 재귀식을 이용할 수 있음 ex) fn(5) = fn(4) + fn(3)
-시간복잡도는 O(2^N)
-fn(100)이면 O(2^100)으로 계산 불가
-메모이제이션 기법으로 이미 계산된 것을 메모리에 담아두어 꺼내 사용할 수 있음
-DP를 사용하기 위한 조건
  1)큰 문제를 작은 문제로 나눌 수 있음
  2)작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일  
-DP의 2가지 방식
  1)탑다운 방식(재귀함수)
  2)보텀업 방식(반복문)
'''

##예제 8-2.메모이제이션 기법을 사용한 피보나치 수열(탑다운 방식)
#메모이제이션하기 위한 리스트 초기화
d = [0] * 100

def fibo(n):
  if n == 1 or n == 2:
    return 1

  #계산한적 있는 문제면 그대로 반환
  if d[n] != 0:
    return d[n]

  #아직 계산한 적 없는 문제면 점화식에 따라 피보나치 결과 반환
  d[n] = fibo(n-1) + fibo(n-2)
  return d[n]

print(fibo(99))

##예제 8-4.메모이제이션 기법을 사용한 피보나치 수열(보텀업 방식)
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
  #점화식
  d[i] = d[i-1] + d[i-2]

print(d[n])


'''
-문제풀 때, 일단 재귀함수로 단순 방식으로 푼 후, 메모이제이션을 적용하는 식으로 개선하는 것도 방법
-가능하면 탑다운 방식보다 보텀업 방식으로 구현하는 것을 권장. 시스템상 재귀함수 스택 크기가 한정되어 있을 수 있음
'''

##실전2. 1로 만들기(동빈북 217p)

'''
-연산의 최소값으로 갱신하여 보텀업 하는 방식
-단순 그리디로 하면 최적의 해(최소값)가 안나옴
-26을 그리디로 풀면 나누기부터 할 것이다.(가장 눈앞의 최소값만 체크하며 나누고 빼기)
-그리디 : 26->13->12->4->2->1 (5번)
-DP : 26->25->5->1 (3번)
-처음에 1을 빼준 후, 나누기들과 최소값을 비교해보면서 가장 최소값으로 셋팅
'''

x = int(input())

#DP테이블 초기화(입력값 1<=x<=30000)
d = [0] * 30001

for i in range(2,x+1):
  #현재 수에서 1뺀 경우
  d[i] = d[i - 1] + 1
  #현재 수가 2로 나누어 떨어지는 경우
  if i%2 == 0:
    d[i] = min(d[i], d[i//2] + 1)
  if i%3 == 0:
    d[i] = min(d[i], d[i//3] + 1)
  if i%5 == 0:
    d[i] = min(d[i], d[i//5] + 1)
print(d[x])

'''
입력
26
출력
3
'''

##실전3. 개미 전사(동빈북 220p)

'''
-DP테이블 d[n]의 값은 n까지의 최적해
'''

#정수 N을 입력받기
n = int(input())
#모든 식량 정보 입력받기
array = list(map(int, input().split()))

#계산된 결과를 저장하는 DP테이블 초기화
d = [0] * 100

#DP 보텀업
d[0] = array[0] #0번째까지의 최적해는 첫번째 식량
d[1] = max(array[0], array[1]) #1번째까지의 최적해는 0번째랑 1번째중 최대값
for i in range(2, n):
  d[i] = max(d[i-1], d[i-2] + array[i])

#계산된 결과 출력
print(d[n - 1])

'''
입력
4
1 3 1 5
출력
8
'''

#실전4.바닥공사(동빈북 223p)

'''
i-1, i-2까지의 2경우만 고려하여 점화식
'''
x = int(input())

d = [0] * 1001

d[1] = 1
d[2] = 3

for i in range(3, x + 1):
  d[i] = (d[i-1] + 2 * d[i-2]) % 796796 #결과값이 너무 커질 수 있어서 임의값 796796 나누기의 나머지로..
  
print(d[x])
  
'''
입력
3
출력
5
'''

##실전5.효율적인 화폐 구성(226p)

'''
-이해 안 된다..다시 봐야할 듯(점화식만드는 법)
'''

n, m = map(int, input().split())
array=  []

for i in range(n):
  array.append(int(input()))
  
#한 번 계산된 결과를 저장하기 위한DP 테이블
d = [10001] * (m + 1)

#다이나믹 프로그래밍 진행(보텀업)
d[0]=0 #0원합을 구하는 것은 0개

for i in range(n):
  for j in range(array[i], m + 1):
    if d[j - array[i]] != 10001: #(i-k)원 만드는 방법 존재
      d[j] = min(d[j], d[j -array[i]] + 1)
      
#계산 결과 출력
if d[m] == 10001:
  print(-1)
else:
  print(d[m])
      
'''
입력
2 15
2
3
출력
5
'''

